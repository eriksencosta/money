## Allocation

Allocation allows the distribution of a monetary amount into parts while guaranteeing that the sum of the parts equals
the original value. For example, a retailer may accept purchases by credit card installments or by buy now, pay later
(BNPL). What happens when a customer makes a purchase totaling USD 100.00 to be paid in three installments?

```kotlin
val price = 100 money "USD"
val number = 3
val installment = price / number
val installments = List(number) { installment } // [USD 33.33, USD 33.33, USD 33.33]
val total = installments.sum()                  // USD 99.99
```

As you noticed, there is a loss of USD 0.01. A penny here and there may seem a slight loss, but it may be
[costly over time](https://slate.com/technology/2019/10/round-floor-software-errors-stock-market-battlefield.html). But
there are other complications as well, such as overcharging a customer (which can be an infringement of
[consumer rights](https://unctad.org/topic/competition-and-consumer-protection/consumer-protection-map) in several
countries) due to rounding issues:

```kotlin
val price = 9973 money "USD"
val number = 6
val installment = price / number
val installments = List(number) { installment } // [USD 1662.17, USD 1662.17,
                                                //  USD 1662.17, USD 1662.17,
                                                //  USD 1662.17, USD 1662.17]
val total = installments.sum()                  // USD 9973.02
```

The library provides a handy `allocate()` method that guarantees the result won't differ from the original amount:

```kotlin
val price = 100 money "USD"
val installments = price allocate 3          // [USD 33.34, USD 33.33, USD 33.33]
val total = installments.allocations().sum() // USD 100.00
```

### Even and proportional allocation

The library supports even and proportional allocation of a given `Money` amount. To allocate evenly, pass an `Int`
to `allocate()`:

```kotlin
val price = 100 money "USD"
val result = price allocate 3
val allocations = result.allocations() // [USD 33.34, USD 33.33, USD 33.33]
val total = allocations.sum()          // USD 100.00
```

To allocate in proportional parts, pass a list of `Percentage`:

```kotlin
val amount = 2345.89 money "USD"
val result = dueAmount allocate listOf(50.percent(), 30.percent(), 20.percent())
val allocations = result.allocations() // [USD 1172.94, USD 703.77, USD 469.18]
val total = allocations.sum()          // USD 2345.89
```

As you can see in the previous examples, both results totaled up to the original monetary amount. No cent was lost or
gained.

### Inspecting the result

The `allocate()` method returns a `Result`, providing a way to inspect the adjustments made to the calculations, i.e.,
the allocation of the missing or extra cent generated by the allocation operation:

```kotlin
val price = 100 money "USD"
val result = price allocate 3
val details = result.details()

details.calculations // [USD 33.33, USD 33.33, USD 33.33]
details.adjustments  // [USD 0.01, USD 0.00, USD 0.00]
details.allocations  // [USD 33.34, USD 33.33, USD 33.33]
```

The `calculations` property holds the result of the allocation operation. The `adjustments` property lists the
adjustments made to guarantee the correctness of the `allocations` property. You may use these values for
accountability, registering all values in the accounting books, or for transparency by sharing them with customers.

You can also query the totals of each property:

```kotlin
details.calculationsTotals // USD 99.99
details.adjustmentsTotals  // USD 0.01
details.allocationsTotals  // USD 100.00
```

### Allocation of the difference

The previous section's example shows that there is a difference (USD 0.01) between the result of the allocation
operation (USD 99.99) and the original amount (USD 100.00). The same example also shows the difference being allocated
in the first item of the resulting allocation list. How does the allocation of the difference work?

In short, the difference is allocated as follows:

* Even allocation: if the difference is positive, allocate it to the first item with the greatest value. If negative,
  distribute each minor unit of the difference to the last item with the smallest value
* Proportional allocation: if the different is positive, distribute each minor unit of the difference to the first item
  with the greatest value. If negative, distribute each minor unit of the difference to the last item of smallest value

This default behavior may be good enough for the majority of use cases. However, as the following section explains, you
can tweak it to suit your needs.

### Configuring the difference allocation

Most of the time, the default implementation will be enough for a broad range of use cases. But you may have a business
rule that specifies the difference should always be allocated in the last element. Guess what? You can tweak the
allocation behavior by directly creating an allocator object. First, let's see the even allocation default behavior:

```kotlin
val price = 100 money "USD"
val result = price allocate 7
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD -0.03]
details.allocations  // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.26]
```

To change the even allocation default behavior, create an `EvenAllocator` object with the desired `DifferenceAllocation`
strategy. Then, call its `allocate()` method:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(OnFirst)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD -0.03, USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00]
details.allocations  // [USD 14.26, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
```

If you want to distribute a negative difference to the last item with the greatest value (as opposed to the default
behavior), use the `DistributeBySign`:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(
    DistributeBySign(
        OnFirstSmallest,
        OnLastGreatest
    )
)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD -0.01, USD -0.01, USD -0.01]
details.allocations  // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.28, USD 14.28, USD 14.28]
```

The steps to tweak the behavior of the proportional allocation are the same. Create a `ProportionalAllocator`
with the desired difference allocation strategy and call the `allocate()` method.

### Allocators hierarchy

By now, you've realized there are two hierarchies of so-called allocators:

* `Allocation` (`com.eriksencosta.money.allocation` package): defines the strategy to allocate a monetary amount (i.e.,
  a `Money` object). The library ships with two possible strategies: `EvenAllocator` and `ProportionalAllocator`
* `DifferenceAllocation` (`com.eriksencosta.money.allocation.difference` package): defines the strategy to allocate the
  difference between the allocation result and the monetary amount that is being allocated

In short, one hierarchy splits a given monetary amount, and another deals with the difference generated by the
allocation operation. As the `Allocation` was fully covered in the previous sections, let's dive in the
`DifferenceAllocation` hierarchy.

### Difference allocation strategies

The `DifferenceAllocation` hierarchy has four interface families:

| Interface                 | Description                                                                                                           | Properties to override                   |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------|------------------------------------------|
| `DifferenceAllocation`    | The root interface, defines the `allocate()` method                                                                   | `allocate()`                             |
| `IndexBasedAllocation`    | Allocates the difference on a specific index in the allocations list                                                  | `allocate()`                             |
| `ValueBasedAllocation`    | Allocates the difference on a specific value in the allocations list                                                  | `applyDifferenceOnValue()`               |
| `SignBasedAllocation`     | Allocates the difference given an `DifferenceAllocation` strategy for positive values and another for negative values | `positiveAllocator`, `negativeAllocator` |
| `DistributableAllocation` | Allocates by distributing each unit of the difference given an `DifferenceAllocation` strategy                        | `allocator`, `distribute()`              |

The root interface, `DifferenceAllocation`, exposes the single method required to integrate with the built-in allocators
for `Money`: `allocate()`. If you want to implement your logic to allocate the difference, create a class or object
implementing this interface and pass it to one of the desired allocators.

For example, if you want to randomly allocate the difference, implement the `IndexBasedAllocation` interface and
override the method `allocate()`:

```kotlin
val randomAllocator = object : IndexBasedAllocation {
  override fun allocate(difference: Money, allocations: List<Money>): List<Money> = run {
    val index = Random.nextInt(0, allocations.size - 1)
    applyDifferenceAtIndex(allocations, difference, index)
  }
}

val price = 100 money "USD"
val allocator = EvenAllocator(randomAllocator)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculationsTotals // USD 100.03
details.adjustmentsTotals  // USD -0.03
details.allocationsTotals  // USD 100.00
```

The following sections explain each interface family type and their implementations.

#### Index based allocation

The `IndexBasedAllocation` hierarchy has two implementations:

| Name      | Description                                                        |
|-----------|--------------------------------------------------------------------|
| `OnFirst` | Allocates the difference to the first item in the allocations list |
| `OnLast`  | Allocates the difference to the last item in the allocations list  |

To use any of these implementations, pass one of them as a parameter to the desired allocator class:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(OnFirst)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD -0.03, USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00]
details.allocations  // [USD 14.26, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
```

#### Value based allocation

The `ValueBasedAllocation` hierarchy has four interfaces and six implementations. The interfaces are explained in the
following table:

| Name                        | Description                                                                          |
|-----------------------------|--------------------------------------------------------------------------------------|
| `OnGreatestValueAllocation` | Allocates the difference to the item with the greatest value in the allocations list |
| `OnSmallestValueAllocation` | Allocates the difference to the item with the smallest value in the allocations list |
| `OnLastValueAllocation`     | Allocates the difference to the last item with a given value                         |
| `OnFirstValueAllocation`    | Allocates the difference to the first item with a given value                        |

These interfaces are designed to be combined as well. The first two interfaces form a group that allocates based on the
value of an item in the allocations list. The last two interfaces form a group that allocates depending on the
ordinality of the list, i.e., on the first or last item with a given value. The implementations of
`ValueBasedAllocation` are explained in the following table:

| Name              | Description                                                                                |
|-------------------|--------------------------------------------------------------------------------------------|
| `OnFirstGreatest` | Allocates the difference to the first item with the greatest value in the allocations list |
| `OnFirstNonZero`  | Allocates the difference to the first item with non-zero value in the allocations list     |
| `OnFirstSmallest` | Allocates the difference to the first item with the smallest value in the allocations list |
| `OnLastGreatest`  | Allocates the difference to the last item with the greatest value in the allocations list  |
| `OnLastNonZero`   | Allocates the difference to the last item with non-zero value in the allocations list      |
| `OnLastSmallest`  | Allocates the difference to the last item with the smallest value in the allocations list  |

To use any of these implementations, pass one of them as a parameter to the desired allocator class:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(OnLastNonZero)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD -0.03]
details.allocations  // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.26]
```

#### Directional allocation

The `SignBasedAllocation` hierarchy has five implementations, fully explained in the following table:

| Name                 | Description                                                                                                                                                                               |
|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `NegativeOnFirst`    | Allocates a negative difference to the first item in the allocations list. Allocates a positive difference on the last non-zero item in the list                                          |
| `NegativeOnGreatest` | Allocates a negative difference to the first item with the greatest value in the allocations list. Distributes a positive difference to the last item with the smallest value in the list |
| `PositiveOnFirst`    | Allocates a positive difference to the first item in the allocations list. Allocates a negative difference on the last non-zero item in the list                                          |
| `PositiveOnGreatest` | Allocates a negative difference to the first item with the greatest value in the allocations list. Distributes a negative difference to the last item with the smallest value in the list |
| `DistributeBySign`   | Distributes a positive or negative difference according to the given `DifferenceAllocation` strategies                                                                                    |

To use any of these implementations, pass one of them as a parameter to the desired allocator class:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(NegativeOnGreatest)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD -0.03, USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00]
details.allocations  // [USD 14.26, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
```

#### Distributable allocation

The `DistributableAllocation` has a single implementation:

| Name         | Description                                                                      |
|--------------|----------------------------------------------------------------------------------|
| `Distribute` | Distributes each unit of the difference given an `DifferenceAllocation` strategy |

The distribution mechanism is particularly useful to smooth the distortion of the resulting allocations list:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(Distribute(OnLastGreatest))
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD -0.01, USD -0.01, USD -0.01]
details.allocations  // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.28, USD 14.28, USD 14.28]
```

#### Disabling the difference allocation

If you want to disable the difference allocation, use the `Discard` strategy:

```kotlin
val price = 100 money "USD"
val allocator = EvenAllocator(Discard)
val result = allocator.allocate(price, 7)
val details = result.details()

details.calculations // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
details.adjustments  // [USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00,  USD 0.00]
details.allocations  // [USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29, USD 14.29]
```

## Code examples

The code examples can be found in the
[UsageExamples](../../money/src/test/kotlin/com/eriksencosta/money/UsageExamples.kt) test file.
